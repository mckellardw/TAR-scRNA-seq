#########################################################################
#    uTAR Snakemake pipeline - **starting from cellranger count output**
#    Copyright (C) 2020 Michael Wang
#		(modified by David McKellar)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
##########################################################################

import pdb
import pandas as pd
########################################################################################################
# Config file
########################################################################################################
configfile:'multi_cellranger_config.yaml'
########################################################################################################
# Directories and locations
########################################################################################################
DATADIR = config['DATADIR']
MERGEDOUTDIR = config['MERGEDOUTDIR']
TMPDIR = config['TMPDIR']
########################################################################################################
# Variables and references
########################################################################################################
CR_REF = config['CR_REF']
CHROMS = list(pd.read_table(CR_REF+'/star/chrName.txt', names=['chr'])['chr'])
print(CHROMS)
SCAFE_GENOME = config['SCAFE_GENOME']

MERGEBP=str(config['MERGEBP'])
THRESH=str(config['THRESH'])
CORES = config['CORES']

########################################################################################################
# Executables
########################################################################################################
PICARD = config['PICARD']
DROPSEQ = config['DROPSEQ']
GTFTOGENEPRED = config['GTFTOGENEPRED']

########################################################################################################
rule all:
############## original default call here
	# input: expand('{DATADIR}/{sample}/multicr_TAR/TAR_diff_uTAR_Features_Labeled.txt', DATADIR=config['DATADIR'], sample=config['Samples'])
	# input: expand('{DATADIR}/{sample}/multicr_TAR/beds/chr1.bed.gz', DATADIR=config['DATADIR'], sample=config['Samples'])
	input:
		MERGED=expand('{MERGEDOUTDIR}', MERGEDOUTDIR=config['MERGEDOUTDIR']),
		# SOLO=expand('{DATADIR}/{sample}/beds/chr1.bed.gz',  DATADIR=config['DATADIR'], sample=config['Samples'])
		SOLO=expand('{DATADIR}/{sample}/beds/{chr}.bed.gz',  DATADIR=config['DATADIR'], sample=config['Samples'], chr = [CHROMS])
# beds/split.sorted.bed.gz
# beds/chr1.bed.gz
# beds/merged_chr1.bed.gz

# rule getMats:
# 	input: expand('{DATADIR}/{sample}/multicr_TAR/getMats.txt', DATADIR=config['DATADIR'], sample=config['Samples'])

#####################################################################################
# Set up before running HMM
#####################################################################################

# create sequence dictionary using picard tools - only need to run once, saves into your cellranger reference
rule createGenomeDict:
        input: CR_REF+'/fasta/genome.fa'
        output: CR_REF+'/fasta/genome.fa'+'.dict'
        shell:
                """
                java -Dpicard.useLegacyParser=false -jar {PICARD} CreateSequenceDictionary \
                        -R {input} \
                        -O {output}
                """

# convert GTF to REFFlat, save in your cellranger reference
# 	not run if REFFlat file exists -  will only need to run this once for each reference genome
rule convertToRefFlat:
        input:  "{CR_REF}/genes/genes.gtf"
        output: "{CR_REF}/genes/genes.refFlat"
        shell:
              	"""
                {GTFTOGENEPRED} -genePredExt -geneNameAsName2 {input} refFlat.tmp
                paste <(cut -f 12 refFlat.tmp) <(cut -f 1-10 refFlat.tmp) > {output}
                rm refFlat.tmp
                """

# Make output directory for TAR results in cellranger count directory, for each individual sample
# rule makeOutDirs:
# 	input: '{DATADIR}/{sample}',
# 	output:
# 		SAMPLEDIR=directory('{DATADIR}/{sample}/multicr_TAR')
# 	shell:
# 		"""
# 		mkdir {output.SAMPLEDIR}
# 		"""

########################################################################################################
# Post-alignment
########################################################################################################

# if combined file is too big, need to downsample
#rule# downSampleBam:
#	input: "combined_bam.bam"
#	output: "combined_bam.bam"
#	shell: """samtools view -s {downSamp} -b {input} > {output}

# Convert the sorted .bam files into bed files, split across each chromosome
#TODO- this is super slow...
# rule bamToChrSplitBeds:
# 	input:
# 		BAM='{DATADIR}/{sample}/outs/possorted_genome_bam.bam' #need absolute path
# 	output:
# 		BED_TEST='{DATADIR}/{sample}/multicr_TAR/beds/split.sorted.bed.gz', #TODO convert to checkpoint?; temp()
# 		BED_DIR=directory('{DATADIR}/{sample}/multicr_TAR/beds/')
# 	params:
# 		DIR='{DATADIR}/{sample}/multicr_TAR'
# 	threads: 1 # not parallelized :(
# 	shell:
# 		"""
# 		bash scripts/bamToChrSplitBeds.bash {input.BAM} {CORES} {params.DIR}
# 		"""

# Convert the sorted .bam file into bed file
rule bamToBed:
	input:
		BAM='{DATADIR}/{sample}/outs/possorted_genome_bam.bam' #need absolute path
	output:
		OUTBED='{DATADIR}/{sample}/multicr_TAR/beds/split.sorted.bed.gz'
	params:
		DIR='{DATADIR}/{sample}/multicr_TAR',
		BED_DIR=directory('{DATADIR}/{sample}/multicr_TAR/beds/')
	threads: 1 # not parallelized :(
	shell:
		"""
		mkdir -p {output.BED_DIR}
		bedtools bamtobed -i {input.BAM} -split | LC_ALL=C sort -k1,1V -k2,2n --parallel=30 | awk '{{print $0}}' | gzip > {output.OUTBED}
		"""

# OPTIONAL- rule to remove template-switch strand invasion artefacts (denoise peaks, speed up HMM slightly as well)
# rule TSOcleanup"
# 	input:
# 		BED='{DATADIR}/{sample}/multicr_TAR/beds/split.sorted.bed.gz'
# 	output:
# 		CLEAN_BED='{DATADIR}/{sample}/multicr_TAR/beds/split.sorted.cleaned.bed.gz'
# 	params:
# 		PREFIX='split.sorted.cleaned',
# 		OUTDIR='{DATADIR}/{sample}/multicr_TAR/beds',
# 		SCAFE_GENOME=SCAFE_GENOME
# 	threads: 1 # not parallelized :(
# 	shell:
# 		"""
# 		scafe.tool.cm.remove_strand_invader \
# 		--overwrite=yes \
# 		--ctss_bed_path={input.BED} \
# 		--genome={params.SCAFE_GENOME} \
# 		--outputPrefix={params.PREFIX} \
# 		--outDir={params.OUTDIR}
# 		"""

# TODO- add spurious-A peak removal
#		Tentatively planning in using a tool from SCAFE, but might need to re-write it...

# TODO - count how many reads were removed for eah of these steps, save in a .log file?

# Convert the bed file into beds, split by chromosome
rule bedToChrSplitBeds:
	input:
		BED='{wildcards.DATADIR}/{wildcards.sample}/multicr_TAR/beds/split.sorted.bed.gz'
	output:
		BED_CHR1='{wildcards.DATADIR}/{wildcards.sample}/multicr_TAR/beds/chr1.bed.gz'
		# BED_CHR='{DATADIR}/{sample}/multicr_TAR/beds/{chr}.bed.gz'
	params:
		OUTDIR='{wildcards.DATADIR}/{wildcards.sample}/multicr_TAR/beds'
	shell:
		"""
		zcat {input.BED}  | awk '{{print $0 >> "{params.OUTDIR}/chr"$1".bed"}}'
		gzip {params.OUTDIR}/*.bed
		"""
		# find -name "chr*.bed" -size -1024k -delete #TODO- need this?

# TODO - checkpoint - make output directory for merged HMM files
checkpoint makeMergedOutDir:
	input:
		'{wildcards.DATADIR}/{wildcards.sample}/multicr_TAR/beds/chr1.bed.gz',
	output:
		directory('{MERGEDOUTDIR}')
	shell:
		"""
		mkdir -p {output}
		"""

rule mergeChrBeds:
	input:
		expand('{DATADIR}/{sample}/multicr_TAR/beds/{chr}.bed.gz', DATADIR=config['DATADIR'], sample=config['Samples'], chr = [CHROMS])
	output:
		DIR=directory('{MERGEDOUTDIR}'),
		MERGECHR='merged.{chr}.bed.gz'
	shell:
		"""
		mkdir -p {output.DIR}
		bedtools merge {wildcards.DATADIR}/{wildcards.sample}/multicr_TAR/beds/{wildcards.chr}
		"""

# TODO merge .bed files for each chromosome
# rule mergeChromBeds
# rule chrBedMerge:
# 	input: MERGEDOUTDIR
# 	output:
# 	shell:
# 	"""
#
# 	"""


# TODO run the hmm on each chromosome, separately - as separate rules?
# Run HMM to find TARs
rule calcHMMbed:
	input: '{DATADIR}/{sample}/outs/possorted_genome_bam.bam' #need absolute path
	output: temp('{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz')
	threads: CORES
	shell:
		"""
		bash scripts/SingleCellHMM_MW.bash {input} {CORES} {MERGEBP} {THRESH} {wildcards.DATADIR}/{wildcards.sample}/TAR
		"""
# Generate annotations from HMM in refFlat format
#		Returns annotations with and without considering strandedness/direction
rule calcHMMrefFlat:
	input:
		BEDGZ='{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz',
		REFFLAT=CR_REF+"/genes/genes.refFlat"
	output:
		# NODIR = '{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz.noDir.genes.refFlat',
		WITHDIR ='{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz.withDir.genes.refFlat'
	shell:
		"""
		Rscript scripts/generate_refFlat_script_both.R {input.REFFLAT} {input.BEDGZ}
		"""

# Convert stranded annotations to gtf format
rule HMM_refFlat_to_gtf_WITHDIR:
	input:
		WITHDIR ='{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz.withDir.genes.refFlat'
	output:
		WITHDIR ='{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz.withDir.genes.refFlat.gtf'
	shell:
		"""
		Rscript scripts/convertRefFlatToGTF.R {input.WITHDIR}
		"""

# Label .bam file with each HMM feature
rule stage3_withDir:
	input:
		TAR_GTF = '{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz.withDir.genes.refFlat.gtf'
	output:
		OUTBAM=temp('{DATADIR}/{sample}/multicr_TAR/TAR_tagged_withDir.bam'),
		bamIndex=temp('{DATADIR}/{sample}/multicr_TAR/TAR_tagged_withDir.bai')
	params:
		INBAM = '{DATADIR}/{sample}/outs/possorted_genome_bam.bam'
	threads: 1
	shell:
		"""
        {DROPSEQ}/TagReadWithGeneFunction\
			I={params.INBAM}\
            O={output.OUTBAM}\
            ANNOTATIONS_FILE={input.TAR_GTF}\
			GENE_NAME_TAG=GN\
			GENE_STRAND_TAG=GS\
			USE_STRAND_INFO=true\
            MAX_RECORDS_IN_RAM=10000000\
			CREATE_INDEX=true
        """

# Uncomment to generate a count matrix that does not consider strandedness
# Convert non-stranded annotations to gtf format
# rule HMM_refFlat_to_gtf_NODIR:
# 	input:
# 		NODIR = '{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz.noDir.genes.refFlat'
# 	output:
# 		NODIR = '{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz.noDir.genes.refFlat.gtf'
# 	shell:
# 		"""
# 		Rscript scripts/convertRefFlatToGTF.R {input.NODIR}
# 		"""

# Uncomment to generate a count matrix that does not consider strandedness
# rule stage3_noDir:
# 	input:
# 		MERGED = '{DATADIR}/{sample}/outs/possorted_genome_bam.bam',
# 		TAR_REFFLAT = '{DATADIR}/{sample}/multicr_TAR/TAR_reads.bed.gz.noDir.genes.refFlat'
# 	output: temp()'{DATADIR}/{sample}/multicr_TAR/TAR_tagged_noDir.bam')
# 	threads: 1
# 	shell:
# 		"""
#         {DROPSEQ}/TagReadWithGeneFunction\
#             O={output}\
#             I={input.MERGED}\
#             ANNOTATIONS_FILE={input.TAR_REFFLAT}\
#             MAX_RECORDS_IN_RAM=10000000\
# 			CREATE_INDEX=true
#         """

########################################################################################################
# Extract expression for each TAR
########################################################################################################

#TODO- Do we need this?
# Remove any non-ACGT characters from cell barcodes list
# rule cleanCellsList:
# 	input:	'{DATADIR}/{sample}/outs/filtered_feature_bc_matrix/barcodes.tsv.gz'
# 	output: '{DATADIR}/{sample}/multicr_TAR/cellList.txt'
# 	shell:
# 		"""
# 		zcat {input} | sed 's/[^ACGT]//g' >> {output}
# 		"""

# Get counts matrix for HMM-annotated features
rule extract_HMM_expression_withDir:
	input:
		BAM = '{DATADIR}/{sample}/multicr_TAR/TAR_tagged_withDir.bam'
	output:
		COUNTS='{DATADIR}/{sample}/multicr_TAR/TAR_expression_matrix_withDir.txt.gz'
	params:
		BARCODES = '{DATADIR}/{sample}/outs/filtered_feature_bc_matrix/barcodes.tsv.gz',
		TMPDIR = TMPDIR
	shell:
		"""
		{DROPSEQ}/DigitalExpression\
			I={input.BAM}\
			O={output.COUNTS}\
			TMP_DIR={params.TMPDIR}\
			CELL_BARCODE_TAG=CB\
			MOLECULAR_BARCODE_TAG=UB\
			GENE_NAME_TAG=GN\
			GENE_STRAND_TAG=GS\
			CELL_BC_FILE={params.BARCODES}
		"""

# Uncomment to generate a count matrix that does not consider strandedness
# rule extract_HMM_expression_noDir:
# 	input:
# 		BAM='{DATADIR}/{sample}/multicr_TAR/TAR_tagged_noDir.bam'
# 		# BARCODES = '{DATADIR}/{sample}/multicr_TAR/cellList.txt'
# 	output: '{DATADIR}/{sample}/multicr_TAR/TAR_expression_matrix_noDir.txt.gz'
# 	params:
# 		sample = '{sample}',
# 		DATADIR = '{DATADIR}',
# 		BARCODES = '{DATADIR}/{sample}/outs/filtered_feature_bc_matrix/barcodes.tsv.gz'
# 	shell:
# 		"""
# 		{DROPSEQ}/DigitalExpression\
# 			I={input.BAM}\
# 			O={output}\
# 			SUMMARY={params.DATADIR}/{params.sample}/multicr_TAR/TAR_noDir_dge.summary.txt \
# 			CELL_BARCODE_TAG=CB\
# 			CELL_BC_FILE={params.BARCODES}
# 		"""

#########################################################
# Diff. TAR expression & BLAST
#########################################################

# generate differentially expressed genes and uTARs
rule getDiffFeatures:
	input:
		hmmFile='{DATADIR}/{sample}/multicr_TAR/TAR_expression_matrix_withDir.txt.gz'
	output:
		diffFeatures='{DATADIR}/{sample}/multicr_TAR/diff_Expressed_Features.txt',
		MTX_DIR=directory('{DATADIR}/{sample}/multicr_TAR/TAR_feature_bc_matrix'),
		MTX_BC='{DATADIR}/{sample}/multicr_TAR/TAR_feature_bc_matrix/barcodes.tsv.gz',
		MTX_FEAT='{DATADIR}/{sample}/multicr_TAR/TAR_feature_bc_matrix/features.tsv.gz',
		MTX_MTX='{DATADIR}/{sample}/multicr_TAR/TAR_feature_bc_matrix/matrix.mtx.gz'
	params:
		geneFile='{DATADIR}/{sample}/outs/filtered_feature_bc_matrix'
	shell:
		"""
		Rscript scripts/analyzeExpressionMat.R {params.geneFile} {input.hmmFile}
		"""

# from diff uTARs, extract fasta region to blast
rule getDiffRegionsToBlast:
	input:
		diffFeatures='{DATADIR}/{sample}/multicr_TAR/diff_Expressed_Features.txt',
		bamFile='{DATADIR}/{sample}/multicr_TAR/TAR_tagged_withDir.bam',
		bamIndex='{DATADIR}/{sample}/multicr_TAR/TAR_tagged_withDir.bai'
	output:
		fastaRegions='{DATADIR}/{sample}/multicr_TAR/TAR_seqsToBlast.txt',
		uTARDiffFeatures='{DATADIR}/{sample}/multicr_TAR/TAR_diff_uTAR_Features.txt'
	shell:
		"""
		Rscript scripts/getFastasForBlast.R {input.diffFeatures} {input.bamFile}
		"""

# extract diff uTAR fastas
rule getDiffSeqsToBlastFa:
	input:
		fastaRegions='{DATADIR}/{sample}/multicr_TAR/TAR_seqsToBlast.txt'
	output:
		TARfasta='{DATADIR}/{sample}/multicr_TAR/TAR_seqsToBlast.fa'
	params:
		fastaFile=CR_REF+'/fasta/genome.fa',
		fastaIndex=CR_REF+'/fasta/genome.fa'+'.dict'
	shell:
		"""
		samtools faidx -r {input.fastaRegions} {params.fastaFile} > {output}
		"""

# run blast on fastas
rule ruleBlast:
	input:
		TARfasta='{DATADIR}/{sample}/multicr_TAR/TAR_seqsToBlast.fa'
	output:
		'{DATADIR}/{sample}/multicr_TAR/TAR_blastResults.txt'
	threads: CORES
	params:
		blastDB=config['BLASTDB']
	shell:
		"""
		blastn -db {params.blastDB}/nt -query {input.TARfasta} -out {output} -outfmt '6 qseqid sseqid stitle pident length mismatch gapopen qstart qend sstart send evalue bitscore' -max_target_seqs 5 -num_threads {CORES}
		"""

# label uTARs based on best blast results
rule labelDiffuTARs:
	input:
		DIFF_FEAT='{DATADIR}/{sample}/multicr_TAR/TAR_diff_uTAR_Features.txt',
		BLAST_RESULT='{DATADIR}/{sample}/multicr_TAR/TAR_blastResults.txt'
	output:
		uTARSummary='{DATADIR}/{sample}/multicr_TAR/TAR_diff_uTAR_Features_Labeled.txt'
	shell:
		"""
		Rscript scripts/examineBlastResults.R {input.DIFF_FEAT} {input.BLAST_RESULT}
		"""

rule getMatsSteps:
	input:
		COUNTS='{DATADIR}/{sample}/multicr_TAR/TAR_expression_matrix_withDir.txt.gz',
		MTX_DIR='{DATADIR}/{sample}/multicr_TAR/TAR_feature_bc_matrix',
		MTX_BC='{DATADIR}/{sample}/multicr_TAR/TAR_feature_bc_matrix/barcodes.tsv.gz',
		MTX_FEAT='{DATADIR}/{sample}/multicr_TAR/TAR_feature_bc_matrix/features.tsv.gz',
		MTX_MTX='{DATADIR}/{sample}/multicr_TAR/TAR_feature_bc_matrix/matrix.mtx.gz',
		# hmm2='{path}/{sample}_TAR_expression_matrix_noDir.txt.gz',
		bamFile='{DATADIR}/{sample}/multicr_TAR/TAR_tagged_withDir.bam',
		bamIndex='{DATADIR}/{sample}/multicr_TAR/TAR_tagged_withDir.bai'
	output: '{DATADIR}/{sample}/multicr_TAR/getMats.txt'
	shell:
		"""echo "Expression matrices ready" > {output}"""
